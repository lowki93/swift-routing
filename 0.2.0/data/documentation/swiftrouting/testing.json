{"schemaVersion":{"major":0,"minor":3,"patch":0},"kind":"article","metadata":{"roleHeading":"API Collection","role":"collectionGroup","title":"Testing Navigation","modules":[{"name":"SwiftRouting"}]},"primaryContentSections":[{"content":[{"type":"heading","text":"Overview","level":2,"anchor":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"SwiftRouting is designed with testability in mind. The protocol-based architecture allows you to mock routers and verify navigation behavior without running UI tests."}]},{"type":"heading","text":"Testing Strategies","level":2,"anchor":"Testing-Strategies"},{"type":"heading","text":"Strategy 1: Mock RouterModel","level":3,"anchor":"Strategy-1-Mock-RouterModel"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Create a mock implementation of "},{"type":"reference","identifier":"doc:\/\/SwiftRouting\/documentation\/SwiftRouting\/RouterModel","isActive":true},{"type":"text","text":" to capture navigation calls:"}]},{"code":["@MainActor","final class MockRouter: RouterModel {","    var pushedRoutes: [any Route] = []","    var presentedRoutes: [any Route] = []","    var coveredRoutes: [any Route] = []","    var backCallCount = 0","    var popToRootCallCount = 0","    var closeCallCount = 0","    ","    func push(_ route: some Route) {","        pushedRoutes.append(route)","    }","    ","    func present(_ route: some Route, withStack: Bool = true) {","        presentedRoutes.append(route)","    }","    ","    func cover(_ route: some Route) {","        coveredRoutes.append(route)","    }","    ","    func back() {","        backCallCount += 1","    }","    ","    func popToRoot() {","        popToRootCallCount += 1","    }","    ","    func close() {","        closeCallCount += 1","    }","    ","    \/\/ Implement other RouterModel requirements as needed","    func route(_ route: some Route) {","        push(route)","    }","    ","    func route(to route: some Route, type: RoutingType) {","        switch type {","        case .push: push(route)","        case .sheet: present(route)","        case .cover: cover(route)","        case .root: break","        }","    }","    ","    func update(root route: some Route) {}","    func closeChildren() {}","    func add<T: RouteContext>(context: T.Type, action: @escaping (T) -> Void) {}","    func remove<T: RouteContext>(context: T.Type) {}","    func context(_ object: some RouteContext) {}","    func terminate(_ object: some RouteContext) {}","}"],"type":"codeListing","syntax":"swift"},{"type":"heading","text":"Strategy 2: Test ViewModel Navigation","level":3,"anchor":"Strategy-2-Test-ViewModel-Navigation"},{"type":"paragraph","inlineContent":[{"text":"Inject the mock router into your ViewModel:","type":"text"}]},{"code":["@MainActor","final class ProfileViewModel {","    private let router: any RouterModel","    private let userId: String","    ","    init(router: any RouterModel, userId: String) {","        self.router = router","        self.userId = userId","    }","    ","    func editProfile() {","        router.push(ProfileRoute.edit(userId: userId))","    }","    ","    func openSettings() {","        router.present(ProfileRoute.settings)","    }","    ","    func logout() {","        router.popToRoot()","    }","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Test the navigation behavior:"}]},{"code":["import Testing","","@Suite(\"ProfileViewModel Navigation\")","struct ProfileViewModelTests {","    ","    @Test","    @MainActor","    func editProfile_pushesEditRoute() {","        let mockRouter = MockRouter()","        let viewModel = ProfileViewModel(router: mockRouter, userId: \"123\")","        ","        viewModel.editProfile()","        ","        #expect(mockRouter.pushedRoutes.count == 1)","        let pushedRoute = mockRouter.pushedRoutes.first as? ProfileRoute","        #expect(pushedRoute == .edit(userId: \"123\"))","    }","    ","    @Test","    @MainActor","    func openSettings_presentsSettingsRoute() {","        let mockRouter = MockRouter()","        let viewModel = ProfileViewModel(router: mockRouter, userId: \"123\")","        ","        viewModel.openSettings()","        ","        #expect(mockRouter.presentedRoutes.count == 1)","        let presentedRoute = mockRouter.presentedRoutes.first as? ProfileRoute","        #expect(presentedRoute == .settings)","    }","    ","    @Test","    @MainActor","    func logout_popsToRoot() {","        let mockRouter = MockRouter()","        let viewModel = ProfileViewModel(router: mockRouter, userId: \"123\")","        ","        viewModel.logout()","        ","        #expect(mockRouter.popToRootCallCount == 1)","    }","}"],"type":"codeListing","syntax":"swift"},{"type":"heading","text":"Testing RouteContext","level":2,"anchor":"Testing-RouteContext"},{"type":"heading","text":"Testing Context Sending","level":3,"anchor":"Testing-Context-Sending"},{"code":["@MainActor","final class MockRouterWithContext: MockRouter {","    var sentContexts: [any RouteContext] = []","    var terminatedContexts: [any RouteContext] = []","    ","    override func context(_ object: some RouteContext) {","        sentContexts.append(object)","    }","    ","    override func terminate(_ object: some RouteContext) {","        terminatedContexts.append(object)","    }","}","","@Test","@MainActor","func selectUser_terminatesWithContext() {","    let mockRouter = MockRouterWithContext()","    let viewModel = UserPickerViewModel(router: mockRouter)","    let user = User(id: \"1\", name: \"John\")","    ","    viewModel.selectUser(user)","    ","    #expect(mockRouter.terminatedContexts.count == 1)","    let context = mockRouter.terminatedContexts.first as? UserSelectionContext","    #expect(context?.selectedUser.id == \"1\")","}"],"type":"codeListing","syntax":"swift"},{"type":"heading","text":"Testing Context Reception","level":3,"anchor":"Testing-Context-Reception"},{"type":"paragraph","inlineContent":[{"type":"text","text":"For testing context handlers, use a real "},{"type":"reference","identifier":"doc:\/\/SwiftRouting\/documentation\/SwiftRouting\/Router","isActive":true},{"type":"text","text":" instance:"}]},{"code":["@Test","@MainActor","func contextHandler_receivesContext() async {","    let router = Router(configuration: .default)","    var receivedUser: User?","    ","    router.add(context: UserSelectionContext.self) { context in","        receivedUser = context.selectedUser","    }","    ","    let user = User(id: \"1\", name: \"John\")","    router.context(UserSelectionContext(selectedUser: user))","    ","    #expect(receivedUser?.id == \"1\")","}"],"type":"codeListing","syntax":"swift"},{"type":"heading","text":"Testing Deep Links","level":2,"anchor":"Testing-Deep-Links"},{"type":"heading","text":"Testing DeeplinkHandler","level":3,"anchor":"Testing-DeeplinkHandler"},{"code":["struct TestDeeplinkHandler: DeeplinkHandler {","    typealias R = DeeplinkIdentifier","    typealias D = AppRoute","    ","    func deeplink(from route: DeeplinkIdentifier) async throws -> DeeplinkRoute<AppRoute>? {","        switch route {","        case .home:","            return .push(.home)","        case .profile(let userId):","            return .push(.profile(userId: userId))","        case .settings:","            return .present(.settings)","        default:","            return nil","        }","    }","}","","@Suite(\"DeeplinkHandler\")","struct DeeplinkHandlerTests {","    ","    @Test","    func homeIdentifier_returnsPushHome() async throws {","        let handler = TestDeeplinkHandler()","        ","        let deeplink = try await handler.deeplink(from: .home)","        ","        #expect(deeplink?.route == .home)","        #expect(deeplink?.type == .push)","    }","    ","    @Test","    func profileIdentifier_returnsPushWithUserId() async throws {","        let handler = TestDeeplinkHandler()","        ","        let deeplink = try await handler.deeplink(from: .profile(userId: \"123\"))","        ","        #expect(deeplink?.route == .profile(userId: \"123\"))","        #expect(deeplink?.type == .push)","    }","    ","    @Test","    func settingsIdentifier_returnsPresent() async throws {","        let handler = TestDeeplinkHandler()","        ","        let deeplink = try await handler.deeplink(from: .settings)","        ","        #expect(deeplink?.route == .settings)","        #expect(deeplink?.type == .sheet(withStack: true))","    }","    ","    @Test","    func unknownIdentifier_returnsNil() async throws {","        let handler = TestDeeplinkHandler()","        ","        let deeplink = try await handler.deeplink(from: .unknown)","        ","        #expect(deeplink == nil)","    }","}"],"type":"codeListing","syntax":"swift"},{"type":"heading","text":"Testing DeeplinkRoute Factories","level":3,"anchor":"Testing-DeeplinkRoute-Factories"},{"code":["@Suite(\"DeeplinkRoute Factories\")","struct DeeplinkRouteFactoryTests {","    ","    @Test","    func push_createsCorrectDeeplink() {","        let deeplink: DeeplinkRoute<AppRoute> = .push(.home, path: [.list])","        ","        #expect(deeplink.route == .home)","        #expect(deeplink.type == .push)","        #expect(deeplink.path.count == 1)","    }","    ","    @Test","    func popToRoot_hasNilRoute() {","        let deeplink: DeeplinkRoute<AppRoute> = .popToRoot()","        ","        #expect(deeplink.route == nil)","    }","    ","    @Test","    func popToRootWithRoot_setsRoot() {","        let deeplink: DeeplinkRoute<AppRoute> = .popToRoot(root: .dashboard)","        ","        #expect(deeplink.root == .dashboard)","        #expect(deeplink.route == nil)","    }","}"],"type":"codeListing","syntax":"swift"},{"type":"heading","text":"Testing TabRouter Navigation","level":2,"anchor":"Testing-TabRouter-Navigation"},{"code":["@MainActor","final class MockTabRouter: TabRouterModel {","    var selectedTab: (any TabRoute)?","    var pushCalls: [(route: any Route, tab: (any TabRoute)?)] = []","    var popToRootCalls: [(any TabRoute)?] = []","    ","    func change(tab: some TabRoute) {","        selectedTab = tab","    }","    ","    func push(_ route: some Route, in tab: (any TabRoute)?) {","        pushCalls.append((route, tab))","    }","    ","    func popToRoot(in tab: (any TabRoute)?) {","        popToRootCalls.append(tab)","    }","    ","    \/\/ Implement other TabRouterModel requirements...","}","","@Test","@MainActor","func crossTabNavigation_pushesToCorrectTab() {","    let mockTabRouter = MockTabRouter()","    let viewModel = HomeViewModel(tabRouter: mockTabRouter)","    ","    viewModel.goToProfile(userId: \"123\")","    ","    #expect(mockTabRouter.pushCalls.count == 1)","    let call = mockTabRouter.pushCalls.first","    #expect((call?.route as? AppRoute) == .profile(userId: \"123\"))","    #expect((call?.tab as? AppTab) == .profile)","}"],"type":"codeListing","syntax":"swift"},{"type":"heading","text":"Best Practices","level":2,"anchor":"Best-Practices"},{"type":"heading","text":"Use Protocol Types","level":3,"anchor":"Use-Protocol-Types"},{"type":"paragraph","inlineContent":[{"text":"Always inject ","type":"text"},{"code":"any RouterModel","type":"codeVoice"},{"text":" or ","type":"text"},{"code":"any TabRouterModel","type":"codeVoice"},{"text":" instead of concrete types:","type":"text"}]},{"code":["\/\/ Good: Protocol type enables mocking","init(router: any RouterModel) { ... }","","\/\/ Avoid: Concrete type is harder to test","init(router: Router) { ... }"],"type":"codeListing","syntax":"swift"},{"type":"heading","text":"Test Navigation Intent, Not Implementation","level":3,"anchor":"Test-Navigation-Intent-Not-Implementation"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Focus on "},{"type":"emphasis","inlineContent":[{"type":"text","text":"what"}]},{"type":"text","text":" navigation should happen, not "},{"type":"emphasis","inlineContent":[{"text":"how","type":"text"}]},{"type":"text","text":":"}]},{"code":["\/\/ Good: Tests the intent","#expect(mockRouter.pushedRoutes.contains { ($0 as? AppRoute) == .profile(userId: \"123\") })","","\/\/ Avoid: Testing implementation details","#expect(mockRouter.path.count == 2)"],"type":"codeListing","syntax":"swift"},{"type":"heading","text":"Keep Mocks Simple","level":3,"anchor":"Keep-Mocks-Simple"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Only implement what you need for each test. Use "},{"code":"fatalError()","type":"codeVoice"},{"type":"text","text":" for unneeded methods during development to catch unexpected calls."}]},{"type":"heading","text":"Test Async Handlers","level":3,"anchor":"Test-Async-Handlers"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Deep link handlers are async. Use Swift Testingâ€™s async support:"}]},{"code":["@Test","func asyncDeeplinkHandler() async throws {","    let handler = MyDeeplinkHandler()","    let result = try await handler.deeplink(from: .someIdentifier)","    #expect(result != nil)","}"],"type":"codeListing","syntax":"swift"}],"kind":"content"}],"sections":[],"hierarchy":{"paths":[["doc:\/\/SwiftRouting\/documentation\/SwiftRouting"]]},"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/SwiftRouting\/documentation\/SwiftRouting\/Testing"},"seeAlsoSections":[{"identifiers":["doc:\/\/SwiftRouting\/documentation\/SwiftRouting\/Architecture"],"title":"Architecture and Testing","anchor":"Architecture-and-Testing","generated":true}],"variants":[{"paths":["\/documentation\/swiftrouting\/testing"],"traits":[{"interfaceLanguage":"swift"}]}],"topicSections":[{"identifiers":["doc:\/\/SwiftRouting\/documentation\/SwiftRouting\/RouterModel","doc:\/\/SwiftRouting\/documentation\/SwiftRouting\/TabRouterModel","doc:\/\/SwiftRouting\/documentation\/SwiftRouting\/DeeplinkHandler","doc:\/\/SwiftRouting\/documentation\/SwiftRouting\/RouteContext"],"title":"Related","anchor":"Related"}],"abstract":[{"type":"text","text":"Learn how to write unit tests for your navigation logic."}],"references":{"doc://SwiftRouting/documentation/SwiftRouting/DeeplinkHandler":{"role":"symbol","type":"topic","kind":"symbol","url":"\/documentation\/swiftrouting\/deeplinkhandler","navigatorTitle":[{"text":"DeeplinkHandler","kind":"identifier"}],"abstract":[{"text":"A protocol for converting an external deeplink input into a ","type":"text"},{"code":"DeeplinkRoute","type":"codeVoice"},{"text":" ","type":"text"},{"text":"that can be handled by the ","type":"text"},{"code":"Router","type":"codeVoice"},{"text":".","type":"text"}],"title":"DeeplinkHandler","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"DeeplinkHandler","kind":"identifier"}],"identifier":"doc:\/\/SwiftRouting\/documentation\/SwiftRouting\/DeeplinkHandler"},"doc://SwiftRouting/documentation/SwiftRouting/RouteContext":{"fragments":[{"text":"typealias","kind":"keyword"},{"text":" ","kind":"text"},{"text":"RouteContext","kind":"identifier"}],"navigatorTitle":[{"text":"RouteContext","kind":"identifier"}],"identifier":"doc:\/\/SwiftRouting\/documentation\/SwiftRouting\/RouteContext","abstract":[{"text":"A type that can be used to pass data between routes and trigger navigation flow completions.","type":"text"}],"title":"RouteContext","role":"symbol","type":"topic","kind":"symbol","url":"\/documentation\/swiftrouting\/routecontext"},"doc://SwiftRouting/documentation/SwiftRouting/Router":{"role":"symbol","abstract":[{"type":"text","text":"Every "},{"type":"codeVoice","code":"RoutingView"},{"type":"text","text":" has his own router"}],"kind":"symbol","identifier":"doc:\/\/SwiftRouting\/documentation\/SwiftRouting\/Router","navigatorTitle":[{"text":"Router","kind":"identifier"}],"title":"Router","type":"topic","url":"\/documentation\/swiftrouting\/router","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Router","kind":"identifier"}]},"doc://SwiftRouting/documentation/SwiftRouting/TabRouterModel":{"kind":"symbol","abstract":[{"text":"Defines navigation capabilities for tab-based navigation within a ","type":"text"},{"code":"ViewModel","type":"codeVoice"},{"text":" or other components.","type":"text"}],"role":"symbol","identifier":"doc:\/\/SwiftRouting\/documentation\/SwiftRouting\/TabRouterModel","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"TabRouterModel"}],"navigatorTitle":[{"kind":"identifier","text":"TabRouterModel"}],"title":"TabRouterModel","type":"topic","url":"\/documentation\/swiftrouting\/tabroutermodel"},"doc://SwiftRouting/documentation/SwiftRouting/RouterModel":{"identifier":"doc:\/\/SwiftRouting\/documentation\/SwiftRouting\/RouterModel","url":"\/documentation\/swiftrouting\/routermodel","type":"topic","kind":"symbol","navigatorTitle":[{"kind":"identifier","text":"RouterModel"}],"abstract":[{"type":"text","text":"Defines navigation capabilities within a "},{"code":"ViewModel","type":"codeVoice"},{"type":"text","text":" or other components."}],"title":"RouterModel","role":"symbol","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"RouterModel"}]},"doc://SwiftRouting/documentation/SwiftRouting":{"identifier":"doc:\/\/SwiftRouting\/documentation\/SwiftRouting","abstract":[{"text":"A lightweight, type-safe navigation framework built on top of NavigationStack for SwiftUI.","type":"text"}],"role":"collection","kind":"symbol","type":"topic","url":"\/documentation\/swiftrouting","title":"SwiftRouting"},"doc://SwiftRouting/documentation/SwiftRouting/Architecture":{"url":"\/documentation\/swiftrouting\/architecture","kind":"article","type":"topic","abstract":[{"text":"Understand the design principles and structure behind SwiftRouting.","type":"text"}],"identifier":"doc:\/\/SwiftRouting\/documentation\/SwiftRouting\/Architecture","title":"Architecture","role":"collectionGroup"}}}