{"identifier":{"url":"doc:\/\/SwiftRouting\/documentation\/SwiftRouting\/Testing","interfaceLanguage":"swift"},"hierarchy":{"paths":[["doc:\/\/SwiftRouting\/documentation\/SwiftRouting"]]},"abstract":[{"text":"Learn how to write unit tests for your navigation logic.","type":"text"}],"sections":[],"primaryContentSections":[{"content":[{"type":"heading","text":"Overview","level":2,"anchor":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"SwiftRouting is designed with testability in mind. The protocol-based architecture allows you to mock routers and verify navigation behavior without running UI tests."}]},{"type":"heading","text":"Testing Strategies","level":2,"anchor":"Testing-Strategies"},{"type":"heading","text":"Strategy 1: Mock RouterModel","level":3,"anchor":"Strategy-1-Mock-RouterModel"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Create a mock implementation of "},{"isActive":true,"type":"reference","identifier":"doc:\/\/SwiftRouting\/documentation\/SwiftRouting\/RouterModel"},{"type":"text","text":" to capture navigation calls:"}]},{"type":"codeListing","code":["@MainActor","final class MockRouter: RouterModel {","    var pushedRoutes: [any Route] = []","    var presentedRoutes: [any Route] = []","    var coveredRoutes: [any Route] = []","    var backCallCount = 0","    var popToRootCallCount = 0","    var closeCallCount = 0","    ","    func push(_ route: some Route) {","        pushedRoutes.append(route)","    }","    ","    func present(_ route: some Route, withStack: Bool = true) {","        presentedRoutes.append(route)","    }","    ","    func cover(_ route: some Route) {","        coveredRoutes.append(route)","    }","    ","    func back() {","        backCallCount += 1","    }","    ","    func popToRoot() {","        popToRootCallCount += 1","    }","    ","    func close() {","        closeCallCount += 1","    }","    ","    \/\/ Implement other RouterModel requirements as needed","    func route(_ route: some Route) {","        push(route)","    }","    ","    func route(to route: some Route, type: RoutingType) {","        switch type {","        case .push: push(route)","        case .sheet: present(route)","        case .cover: cover(route)","        case .root: break","        }","    }","    ","    func update(root route: some Route) {}","    func closeChildren() {}","    func add<T: RouteContext>(context: T.Type, action: @escaping (T) -> Void) {}","    func remove<T: RouteContext>(context: T.Type) {}","    func context(_ object: some RouteContext) {}","    func terminate(_ object: some RouteContext) {}","}"],"syntax":"swift"},{"type":"heading","text":"Strategy 2: Test ViewModel Navigation","level":3,"anchor":"Strategy-2-Test-ViewModel-Navigation"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Inject the mock router into your ViewModel:"}]},{"type":"codeListing","code":["@MainActor","final class ProfileViewModel {","    private let router: any RouterModel","    private let userId: String","    ","    init(router: any RouterModel, userId: String) {","        self.router = router","        self.userId = userId","    }","    ","    func editProfile() {","        router.push(ProfileRoute.edit(userId: userId))","    }","    ","    func openSettings() {","        router.present(ProfileRoute.settings)","    }","    ","    func logout() {","        router.popToRoot()","    }","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"Test the navigation behavior:","type":"text"}]},{"type":"codeListing","code":["import Testing","","@Suite(\"ProfileViewModel Navigation\")","struct ProfileViewModelTests {","    ","    @Test","    @MainActor","    func editProfile_pushesEditRoute() {","        let mockRouter = MockRouter()","        let viewModel = ProfileViewModel(router: mockRouter, userId: \"123\")","        ","        viewModel.editProfile()","        ","        #expect(mockRouter.pushedRoutes.count == 1)","        let pushedRoute = mockRouter.pushedRoutes.first as? ProfileRoute","        #expect(pushedRoute == .edit(userId: \"123\"))","    }","    ","    @Test","    @MainActor","    func openSettings_presentsSettingsRoute() {","        let mockRouter = MockRouter()","        let viewModel = ProfileViewModel(router: mockRouter, userId: \"123\")","        ","        viewModel.openSettings()","        ","        #expect(mockRouter.presentedRoutes.count == 1)","        let presentedRoute = mockRouter.presentedRoutes.first as? ProfileRoute","        #expect(presentedRoute == .settings)","    }","    ","    @Test","    @MainActor","    func logout_popsToRoot() {","        let mockRouter = MockRouter()","        let viewModel = ProfileViewModel(router: mockRouter, userId: \"123\")","        ","        viewModel.logout()","        ","        #expect(mockRouter.popToRootCallCount == 1)","    }","}"],"syntax":"swift"},{"type":"heading","text":"Testing RouteContext","level":2,"anchor":"Testing-RouteContext"},{"type":"heading","text":"Testing Context Sending","level":3,"anchor":"Testing-Context-Sending"},{"type":"codeListing","code":["@MainActor","final class MockRouterWithContext: MockRouter {","    var sentContexts: [any RouteContext] = []","    var terminatedContexts: [any RouteContext] = []","    ","    override func context(_ object: some RouteContext) {","        sentContexts.append(object)","    }","    ","    override func terminate(_ object: some RouteContext) {","        terminatedContexts.append(object)","    }","}","","@Test","@MainActor","func selectUser_terminatesWithContext() {","    let mockRouter = MockRouterWithContext()","    let viewModel = UserPickerViewModel(router: mockRouter)","    let user = User(id: \"1\", name: \"John\")","    ","    viewModel.selectUser(user)","    ","    #expect(mockRouter.terminatedContexts.count == 1)","    let context = mockRouter.terminatedContexts.first as? UserSelectionContext","    #expect(context?.selectedUser.id == \"1\")","}"],"syntax":"swift"},{"type":"heading","text":"Testing Context Reception","level":3,"anchor":"Testing-Context-Reception"},{"type":"paragraph","inlineContent":[{"text":"For testing context handlers, use a real ","type":"text"},{"isActive":true,"type":"reference","identifier":"doc:\/\/SwiftRouting\/documentation\/SwiftRouting\/Router"},{"text":" instance:","type":"text"}]},{"type":"codeListing","code":["@Test","@MainActor","func contextHandler_receivesContext() async {","    let router = Router(configuration: .default)","    var receivedUser: User?","    ","    router.add(context: UserSelectionContext.self) { context in","        receivedUser = context.selectedUser","    }","    ","    let user = User(id: \"1\", name: \"John\")","    router.context(UserSelectionContext(selectedUser: user))","    ","    #expect(receivedUser?.id == \"1\")","}"],"syntax":"swift"},{"type":"heading","text":"Testing Deep Links","level":2,"anchor":"Testing-Deep-Links"},{"type":"heading","text":"Testing DeeplinkHandler","level":3,"anchor":"Testing-DeeplinkHandler"},{"type":"codeListing","code":["struct TestDeeplinkHandler: DeeplinkHandler {","    typealias R = DeeplinkIdentifier","    typealias D = AppRoute","    ","    func deeplink(from route: DeeplinkIdentifier) async throws -> DeeplinkRoute<AppRoute>? {","        switch route {","        case .home:","            return .push(.home)","        case .profile(let userId):","            return .push(.profile(userId: userId))","        case .settings:","            return .present(.settings)","        default:","            return nil","        }","    }","}","","@Suite(\"DeeplinkHandler\")","struct DeeplinkHandlerTests {","    ","    @Test","    func homeIdentifier_returnsPushHome() async throws {","        let handler = TestDeeplinkHandler()","        ","        let deeplink = try await handler.deeplink(from: .home)","        ","        #expect(deeplink?.route == .home)","        #expect(deeplink?.type == .push)","    }","    ","    @Test","    func profileIdentifier_returnsPushWithUserId() async throws {","        let handler = TestDeeplinkHandler()","        ","        let deeplink = try await handler.deeplink(from: .profile(userId: \"123\"))","        ","        #expect(deeplink?.route == .profile(userId: \"123\"))","        #expect(deeplink?.type == .push)","    }","    ","    @Test","    func settingsIdentifier_returnsPresent() async throws {","        let handler = TestDeeplinkHandler()","        ","        let deeplink = try await handler.deeplink(from: .settings)","        ","        #expect(deeplink?.route == .settings)","        #expect(deeplink?.type == .sheet(withStack: true))","    }","    ","    @Test","    func unknownIdentifier_returnsNil() async throws {","        let handler = TestDeeplinkHandler()","        ","        let deeplink = try await handler.deeplink(from: .unknown)","        ","        #expect(deeplink == nil)","    }","}"],"syntax":"swift"},{"type":"heading","text":"Testing DeeplinkRoute Factories","level":3,"anchor":"Testing-DeeplinkRoute-Factories"},{"type":"codeListing","code":["@Suite(\"DeeplinkRoute Factories\")","struct DeeplinkRouteFactoryTests {","    ","    @Test","    func push_createsCorrectDeeplink() {","        let deeplink: DeeplinkRoute<AppRoute> = .push(.home, path: [.list])","        ","        #expect(deeplink.route == .home)","        #expect(deeplink.type == .push)","        #expect(deeplink.path.count == 1)","    }","    ","    @Test","    func popToRoot_hasNilRoute() {","        let deeplink: DeeplinkRoute<AppRoute> = .popToRoot()","        ","        #expect(deeplink.route == nil)","    }","    ","    @Test","    func popToRootWithRoot_setsRoot() {","        let deeplink: DeeplinkRoute<AppRoute> = .popToRoot(root: .dashboard)","        ","        #expect(deeplink.root == .dashboard)","        #expect(deeplink.route == nil)","    }","}"],"syntax":"swift"},{"type":"heading","text":"Testing TabRouter Navigation","level":2,"anchor":"Testing-TabRouter-Navigation"},{"type":"codeListing","code":["@MainActor","final class MockTabRouter: TabRouterModel {","    var selectedTab: (any TabRoute)?","    var pushCalls: [(route: any Route, tab: (any TabRoute)?)] = []","    var popToRootCalls: [(any TabRoute)?] = []","    ","    func change(tab: some TabRoute) {","        selectedTab = tab","    }","    ","    func push(_ route: some Route, in tab: (any TabRoute)?) {","        pushCalls.append((route, tab))","    }","    ","    func popToRoot(in tab: (any TabRoute)?) {","        popToRootCalls.append(tab)","    }","    ","    \/\/ Implement other TabRouterModel requirements...","}","","@Test","@MainActor","func crossTabNavigation_pushesToCorrectTab() {","    let mockTabRouter = MockTabRouter()","    let viewModel = HomeViewModel(tabRouter: mockTabRouter)","    ","    viewModel.goToProfile(userId: \"123\")","    ","    #expect(mockTabRouter.pushCalls.count == 1)","    let call = mockTabRouter.pushCalls.first","    #expect((call?.route as? AppRoute) == .profile(userId: \"123\"))","    #expect((call?.tab as? AppTab) == .profile)","}"],"syntax":"swift"},{"type":"heading","text":"Best Practices","level":2,"anchor":"Best-Practices"},{"type":"heading","text":"Use Protocol Types","level":3,"anchor":"Use-Protocol-Types"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Always inject "},{"code":"any RouterModel","type":"codeVoice"},{"type":"text","text":" or "},{"code":"any TabRouterModel","type":"codeVoice"},{"type":"text","text":" instead of concrete types:"}]},{"type":"codeListing","code":["\/\/ Good: Protocol type enables mocking","init(router: any RouterModel) { ... }","","\/\/ Avoid: Concrete type is harder to test","init(router: Router) { ... }"],"syntax":"swift"},{"type":"heading","text":"Test Navigation Intent, Not Implementation","level":3,"anchor":"Test-Navigation-Intent-Not-Implementation"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Focus on "},{"inlineContent":[{"type":"text","text":"what"}],"type":"emphasis"},{"type":"text","text":" navigation should happen, not "},{"inlineContent":[{"text":"how","type":"text"}],"type":"emphasis"},{"type":"text","text":":"}]},{"type":"codeListing","code":["\/\/ Good: Tests the intent","#expect(mockRouter.pushedRoutes.contains { ($0 as? AppRoute) == .profile(userId: \"123\") })","","\/\/ Avoid: Testing implementation details","#expect(mockRouter.path.count == 2)"],"syntax":"swift"},{"type":"heading","text":"Keep Mocks Simple","level":3,"anchor":"Keep-Mocks-Simple"},{"type":"paragraph","inlineContent":[{"text":"Only implement what you need for each test. Use ","type":"text"},{"code":"fatalError()","type":"codeVoice"},{"text":" for unneeded methods during development to catch unexpected calls.","type":"text"}]},{"type":"heading","text":"Test Async Handlers","level":3,"anchor":"Test-Async-Handlers"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Deep link handlers are async. Use Swift Testingâ€™s async support:"}]},{"type":"codeListing","code":["@Test","func asyncDeeplinkHandler() async throws {","    let handler = MyDeeplinkHandler()","    let result = try await handler.deeplink(from: .someIdentifier)","    #expect(result != nil)","}"],"syntax":"swift"}],"kind":"content"}],"schemaVersion":{"minor":3,"patch":0,"major":0},"kind":"article","topicSections":[{"title":"Related","identifiers":["doc:\/\/SwiftRouting\/documentation\/SwiftRouting\/RouterModel","doc:\/\/SwiftRouting\/documentation\/SwiftRouting\/TabRouterModel","doc:\/\/SwiftRouting\/documentation\/SwiftRouting\/DeeplinkHandler","doc:\/\/SwiftRouting\/documentation\/SwiftRouting\/RouteContext"],"anchor":"Related"}],"seeAlsoSections":[{"anchor":"Architecture-and-Testing","title":"Architecture and Testing","identifiers":["doc:\/\/SwiftRouting\/documentation\/SwiftRouting\/Architecture"],"generated":true}],"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/swiftrouting\/testing"]}],"metadata":{"role":"collectionGroup","modules":[{"name":"SwiftRouting"}],"roleHeading":"API Collection","title":"Testing Navigation"},"references":{"doc://SwiftRouting/documentation/SwiftRouting/RouteContext":{"title":"RouteContext","role":"symbol","kind":"symbol","url":"\/documentation\/swiftrouting\/routecontext","fragments":[{"kind":"keyword","text":"typealias"},{"kind":"text","text":" "},{"kind":"identifier","text":"RouteContext"}],"navigatorTitle":[{"kind":"identifier","text":"RouteContext"}],"type":"topic","identifier":"doc:\/\/SwiftRouting\/documentation\/SwiftRouting\/RouteContext","abstract":[{"type":"text","text":"A type that can be used to pass data between routes and trigger navigation flow completions."}]},"doc://SwiftRouting/documentation/SwiftRouting/RouterModel":{"url":"\/documentation\/swiftrouting\/routermodel","kind":"symbol","title":"RouterModel","type":"topic","navigatorTitle":[{"text":"RouterModel","kind":"identifier"}],"identifier":"doc:\/\/SwiftRouting\/documentation\/SwiftRouting\/RouterModel","abstract":[{"type":"text","text":"Defines navigation capabilities within a "},{"type":"codeVoice","code":"ViewModel"},{"type":"text","text":" or other components."}],"role":"symbol","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"RouterModel","kind":"identifier"}]},"doc://SwiftRouting/documentation/SwiftRouting/DeeplinkHandler":{"url":"\/documentation\/swiftrouting\/deeplinkhandler","title":"DeeplinkHandler","navigatorTitle":[{"kind":"identifier","text":"DeeplinkHandler"}],"type":"topic","role":"symbol","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"DeeplinkHandler"}],"identifier":"doc:\/\/SwiftRouting\/documentation\/SwiftRouting\/DeeplinkHandler","abstract":[{"type":"text","text":"A protocol for converting an external deeplink input into a "},{"type":"codeVoice","code":"DeeplinkRoute"},{"type":"text","text":" "},{"type":"text","text":"that can be handled by the "},{"type":"codeVoice","code":"Router"},{"type":"text","text":"."}],"kind":"symbol"},"doc://SwiftRouting/documentation/SwiftRouting/Router":{"identifier":"doc:\/\/SwiftRouting\/documentation\/SwiftRouting\/Router","title":"Router","navigatorTitle":[{"kind":"identifier","text":"Router"}],"url":"\/documentation\/swiftrouting\/router","kind":"symbol","role":"symbol","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"Router"}],"abstract":[{"text":"Every ","type":"text"},{"code":"RoutingView","type":"codeVoice"},{"text":" has his own router","type":"text"}],"type":"topic"},"doc://SwiftRouting/documentation/SwiftRouting":{"title":"SwiftRouting","identifier":"doc:\/\/SwiftRouting\/documentation\/SwiftRouting","abstract":[{"text":"A lightweight, type-safe navigation framework built on top of NavigationStack for SwiftUI.","type":"text"}],"kind":"symbol","role":"collection","url":"\/documentation\/swiftrouting","type":"topic"},"doc://SwiftRouting/documentation/SwiftRouting/TabRouterModel":{"role":"symbol","type":"topic","url":"\/documentation\/swiftrouting\/tabroutermodel","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"TabRouterModel","kind":"identifier"}],"abstract":[{"type":"text","text":"Defines navigation capabilities for tab-based navigation within a "},{"type":"codeVoice","code":"ViewModel"},{"type":"text","text":" or other components."}],"navigatorTitle":[{"text":"TabRouterModel","kind":"identifier"}],"title":"TabRouterModel","identifier":"doc:\/\/SwiftRouting\/documentation\/SwiftRouting\/TabRouterModel","kind":"symbol"},"doc://SwiftRouting/documentation/SwiftRouting/Architecture":{"title":"Architecture","kind":"article","role":"collectionGroup","url":"\/documentation\/swiftrouting\/architecture","abstract":[{"text":"Understand the design principles and structure behind SwiftRouting.","type":"text"}],"identifier":"doc:\/\/SwiftRouting\/documentation\/SwiftRouting\/Architecture","type":"topic"}}}